/* vim: set ft=cpp noexpandtab fileencoding=utf-8 nomodified wrap textwidth=0 foldmethod=marker foldmarker={{{,}}} foldcolumn=4 ruler showcmd lcs=tab\:|- list: tabstop=8 linebreak showbreak=Â»\   */
// ,,g = gcc, exactly one space after "set"

DÄ›kuji mnohokrÃ¡t za odpovÄ›Ä, pÅ™esnÄ› tohle jsem potÅ™eboval. Jenom mi dlouho trvalo to pochopit a zpracovat.

Tady na GitHubu https://github.com/githubgilhad/memxFORTH-init je prvnÃ­ ÃºspÄ›Å¡nÃ½ pokus o pouÅ¾itÃ­ __memx ukazatelÅ¯ pro prÃ¡ci se seznamem slov pro nÄ›co jako FORTH.

Pro prÃ¡ci s ukazateli pouÅ¾Ã­vÃ¡m union ptr24_u, kterÃ½ pÅ™evÃ¡dÃ­ mezi __memx ukazateli, uint32_t a 3/4 byty.

WORD je pamÄ›ti uloÅ¾enÃ½ jako odkaz na nÃ¡sledujÃ­cÃ­ definici, flagy, dÃ©lka jmÃ©na, jmÃ©no a codeword (ukazatel na spustitelnÃ½ kÃ³d), pÅ™Ã­padnÄ› nÃ¡sledovanÃ½ polem odkazÅ¯ na dalÅ¡Ã­ slova (na jejich codewordy).

Slovo WORDS je vytvoÅ™eno aÅ¾ po startu programu v RAM, slova  TEST EXIT DEBUG TROUBLE DOUBLE + DUP jsou uloÅ¾eny ve FLASH. TROUBLE je hidden pro test flagÅ¯. Pro uloÅ¾enÃ­ do FLASH sem pouÅ¾il asembler (asm.S).

ProblÃ©m s asemblerem je, Å¾e adresy funkcÃ­ do dat (.word) uklÃ¡dÃ¡ jako adresu v bytech, ale pro skoky a volÃ¡nÃ­ pouÅ¾Ã­vÃ¡ adresy ve slovech, takÅ¾e takto vytvoÅ™enÃ© codewordy je nutno po naÄtenÃ­ vydÄ›lit dvÄ›ma (a pÅ™i uklÃ¡dÃ¡nÃ­ do RAM naopak dvÄ›ma nÃ¡sobit, aby vÃ½sledky byly konzistentnÃ­).


.. code::

	7c 06                   ; .word f_docol
	0e 94 3e 03  call 0x67c ; 0x67c <f_docol>

Zde je vidÄ›t, Å¾e adresa f_docol jako data je uloÅ¾ena jako 0x067C, zatÃ­mco pÅ™i skoku na ni se uloÅ¾Ã­ jako 0x033e (a to je i hodnota pro registr Z pro nepÅ™Ã­mÃ© skoky/volÃ¡nÃ­), ale disassembler ji v komentÃ¡Å™i pÅ™evede na bytovou adresu.

Pro ÄtenÃ­ bytu z __memx ukazatele se mi (pro atmega328P - Arduino Nano, UNO) generuje takovÃ½to kÃ³d:


.. code::

	f3 01  movw   r30, r6  ; get 2B address
	84 91  lpm    r24, Z   ; read byte from FLASH
	87 fc  sbrc   r8, 7    ; test top bit of 3. byte in address, skip next instruction, if the bit is zero
	80 81  ld     r24, Z   ; read byte from RAM

takÅ¾e adresy 0 .. 0x7FFFFF se Ätou z FLASH a adresy 0x800000 .. 0xFFFFFF se pÅ™eÄtou z FLASH a potom jeÅ¡tÄ› z RAM (takÅ¾e ve vÃ½sledku je hodnota z RAM).

Pro vÃ­ce bytÅ¯ se pouÅ¾ijÃ­ vestavÄ›nÃ© funkce, kde je na zaÄÃ¡tku rozeskok podle 3.bytu a pak buÄ sÃ©rie LPM, nebo sÃ©rie LD.

Ten repozitÃ¡Å™ je prvnÃ­ ÃºspÄ›Å¡nÃ½ vÃ½sledek, takÅ¾e program skoro nic nedÄ›lÃ¡ a vypisuje spoustu debugovacÃ­ch informacÃ­, jak se mÄ›nÃ­ hodnoty promÄ›nnÃ½ch a pamÄ›Å¥. MÅ¯j hlavnÃ­ projekt bude v jinÃ©m repozitÃ¡Å™i, ale z hlediska pouÅ¾itÃ­ __memx ukazatelÅ¯ uÅ¾ asi nepÅ™inese nic novÃ©ho, jen situaci znepÅ™ehlednÃ­ pÅ™idÃ¡vÃ¡nÃ­m dalÅ¡Ã­ch slov a zÃ¡vislostÃ­. Jeho repozitÃ¡Å™ jsem pÅ™idÃ¡m pozdÄ›ji (aÅ¾ vznikne).

Pokud by byl zÃ¡jem, mÅ¯Å¾u i tento testovacÃ­ repozitÃ¡Å™ jeÅ¡tÄ› nÄ›kam rozvinout, ale nevÃ­m, co by se sem dÃ¡l hodilo.



--------------------------------------------------------------------------------



ChatGPT said:

JasnÄ›! ğŸ˜Š Tady je stejnÃ½ text, pÅ™ipravenÃ½ pro Arduino fÃ³rum (kterÃ© pouÅ¾Ã­vÃ¡ klasickÃ½ Markdown s mÃ­rnÃ½mi Ãºpravami â€” hlavnÄ› mÃ­sto ``` musÃ­Å¡ pouÅ¾Ã­vat [code]...[/code] tagy):

DÄ›kuji mnohokrÃ¡t za odpovÄ›Ä, pÅ™esnÄ› tohle jsem potÅ™eboval. Jenom mi chvÃ­li trvalo vÅ¡e pochopit a zpracovat.

Tady na GitHubu:
https://github.com/githubgilhad/memxFORTH-init
je prvnÃ­ ÃºspÄ›Å¡nÃ½ pokus o pouÅ¾itÃ­ __memx ukazatelÅ¯ pro prÃ¡ci se seznamem slov pro nÄ›co jako FORTH.

Pro prÃ¡ci s ukazateli pouÅ¾Ã­vÃ¡m union ptr24_u, kterÃ½ pÅ™evÃ¡dÃ­ mezi __memx ukazateli, uint32_t a 3/4bytovÃ½mi strukturami.

KaÅ¾dÃ© slovo (WORD) je v pamÄ›ti uloÅ¾eno jako:

    odkaz na pÅ™edchozÃ­ slovo (prochÃ¡zenÃ­ slovnÃ­kem),

    flagy,

    dÃ©lka jmÃ©na,

    jmÃ©no,

    codeword (ukazatel na spustitelnÃ½ kÃ³d),

    pÅ™Ã­padnÄ› nÃ¡sledovanÃ© polem odkazÅ¯ na dalÅ¡Ã­ slova (pro interpret).

Slovo WORDS je vytvoÅ™eno aÅ¾ za bÄ›hu v RAM.
Slova TEST, EXIT, DEBUG, TROUBLE, DOUBLE, +, DUP jsou uloÅ¾enÃ¡ ve FLASH.
(TROUBLE je hidden pro testovÃ¡nÃ­ flagÅ¯.)

Pro uloÅ¾enÃ­ slov do FLASH jsem pouÅ¾il assembler (asm.S).
Pozor â€” assembler uklÃ¡dÃ¡ adresy funkcÃ­ jako byty (.word), ale pro skoky a volÃ¡nÃ­ pouÅ¾Ã­vÃ¡ adresy ve slovech.
TakÅ¾e pÅ™i prÃ¡ci je tÅ™eba adresy ruÄnÄ› upravovat:

    pÅ™i ÄtenÃ­ z dat: dÄ›lit 2 (bajtovÃ¡ adresa â†’ slovnÃ­ adresa),

    pÅ™i uklÃ¡dÃ¡nÃ­ do RAM: nÃ¡sobit 2 (slovnÃ­ adresa â†’ bajtovÃ¡).

PÅ™Ã­klad:

[code] 7c 06 ; .word f_docol 0e 94 3e 03 ; call 0x67c <f_docol> [/code]

Zde .word uloÅ¾Ã­ adresu jako 0x067C, ale instrukce call pouÅ¾Ã­vÃ¡ adresu 0x033E (adresovÃ¡nÃ­ ve slovech).

Pro ÄtenÃ­ bytu z __memx ukazatele generuje AVR-GCC (na ATmega328P) tento kÃ³d:

[code] f3 01 movw r30, r6 ; naÄti 2B adresu 84 91 lpm r24, Z ; Äti byte z FLASH 87 fc sbrc r8, 7 ; pokud je 7. bit 3. bytu adresy 1, pÅ™eskoÄ 80 81 ld r24, Z ; jinak Äti z RAM [/code]

    Adresy 0x000000 aÅ¾ 0x7FFFFF se Ätou z FLASH.

    Adresy 0x800000 aÅ¾ 0xFFFFFF se Ätou z RAM.

Pro vÃ­ce bajtÅ¯ se pouÅ¾Ã­vajÃ­ funkce jako memcpy_PF, kde je nejdÅ™Ã­v rozhodnutÃ­ podle 3. bytu a pak buÄ sÃ©rie LPM, nebo LD.
ShrnutÃ­ projektu

Tento repozitÃ¡Å™ je prvnÃ­ ÃºspÄ›Å¡nÃ½ vÃ½sledek, takÅ¾e program zatÃ­m:

    skoro nic nedÄ›lÃ¡ (demo ÃºÄel),

    vypisuje hodnÄ› debugovacÃ­ch informacÃ­ o pamÄ›ti,

    demonstruje funkÄnÃ­ sjednocenÃ­ RAM a FLASH pÅ™es __memx.

MÅ¯j hlavnÃ­ projekt bude pozdÄ›ji v jinÃ©m repozitÃ¡Å™i (bude stavÄ›t na tÄ›chto zÃ¡kladech, ale bude obsahovat vÃ­ce slov a komplexnÄ›jÅ¡Ã­ strukturu).

Pokud by byl zÃ¡jem, mohu tento testovacÃ­ repozitÃ¡Å™ jeÅ¡tÄ› rozÅ¡Ã­Å™it, ale aktuÃ¡lnÄ› povaÅ¾uji cÃ­le za splnÄ›nÃ©.
PoznÃ¡mka

    PÅ™edhodil jsem FORTHu ÄÃ­slo 0x21 a slovo : DOUBLE DUP + ;.
    Na zÃ¡sobnÃ­ku zÅ¯stal vÃ½sledek 0x42.
    Beru to jako hezkou hexadecimÃ¡lnÃ­ odpovÄ›Ä! ğŸ˜Š



--------------------------------------------------------------------------------





--------------------------------------------------------------------------------




Thank you very much for your reply - this is exactly what I needed.

It just took me some time to fully understand and process it.

Here on GitHub:
https://github.com/githubgilhad/memxFORTH-init
is my first successful attempt at using **__memx** pointers to manage a dictionary of words for something like a Forth interpreter.

For pointer handling, I use a union **ptr24_u**, which allows conversion between **__memx** pointers, **uint32_t**, and **raw 3/4 byte** representations.

Each word (WORD) in memory consists of:

*    a pointer to the previous word (for dictionary traversal),
*    flags,
*    name length,
*    name string,
*    codeword (pointer to executable code),
*    optionally followed by a list of referenced words (for compiled definitions - each is also 24bit pointer to codeword).

The WORDS word is built dynamically in RAM during program startup.

The words TEST, EXIT, DEBUG, TROUBLE, DOUBLE, +, and DUP are stored in FLASH. (TROUBLE is hidden to test flag handling.)

I use an assembler file (asm.S) to place definitions into FLASH.

Note that when storing function addresses as data (.word), the assembler saves them as **byte** addresses, while for jumps/calls it expects **word** addresses.
Thus, you need to:

*    divide by 2 when reading addresses from data sections,
*    multiply by 2 when writing back to RAM structures to maintain consistency.

**Example:**

    7c 06       ; .word f_docol 
    0e 94 3e 03 ; call 0x67c <f_docol> 

You can see .word saves 0x067C, while call uses 0x033E internally (because call addresses are in words, not bytes). The value 0x033E is, what register Z (for indirect jumps) should contain, but disassembler translate comments to the byte representation too.

For reading a single byte through a __memx pointer, AVR-GCC (on ATmega328P - Arduino Nano, UNO) generates code like this:

    f3 01   movw r30, r6 ; move 2B address to Z 
    84 91   lpm r24, Z   ; read byte from FLASH 
    87 fc   sbrc r8, 7   ; test top bit of 3rd byte 
    80 81   ld r24, Z   ; if set, load from RAM instead

*    Addresses from 0x000000 to 0x7FFFFF are read from FLASH.
*    Addresses from 0x800000 to 0xFFFFFF are read from RAM.

For multi-byte reads, built-in functions (like **\_\_xload\_#**) are used, which first check the top address byte and then select between LPM and LD operations.

Project Summary
---------------

This repository 
[(memxFORTH-init)][1] is a minimal, working proof of concept:

*    it doesn't do much,
*    it prints a lot of debug output showing variable and memory state,
*    it demonstrates how to unify RAM and FLASH word access via __memx.

My main project will later be in another repository (building upon these foundations, with more words and more complex behavior).

If there's interest, I could expand this demo a little further - but the main technical goal is already achieved.

**Fun note**


    I threw 0x21 onto the FORTH stack together with the definition : DOUBLE DUP + ;
    After execution, 0x42 remained on the stack.
    Iâ€™ll consider that a perfect hexadecimal answer!


  [1]: https://github.com/githubgilhad/memxFORTH-init
